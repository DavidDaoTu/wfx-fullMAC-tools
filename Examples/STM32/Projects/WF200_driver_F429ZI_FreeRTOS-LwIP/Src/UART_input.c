/**************************************************************************//**
 * Copyright 2018, Silicon Laboratories Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *****************************************************************************/
 
/* Standard includes. */
#include "cmsis_os.h"
#include "string.h"
#include "stm32f4xx_hal.h"

extern UART_HandleTypeDef huart3;

/* Dimensions the buffer into which input characters are placed. */
#define INPUT_SIZE			50

//wait 1 ms
#define WAIT_TIME_1MS ( 1UL / portTICK_RATE_MS ) 

/*
 * The task that implements the command console processing.
 */
static void prvUARTInputTask(void const * pvParameters );

/*-----------------------------------------------------------*/

/* Holds the handle of the task that implements the UART command console. */

static const char * const pcNewLine = ( char * ) "\r\n";


/*-----------------------------------------------------------*/
osThreadId UARTInputTaskHandle;
extern SemaphoreHandle_t uart3Semaphore;
char string_output[INPUT_SIZE];
char UART_Input_String[ INPUT_SIZE ];
SemaphoreHandle_t stringRcvSemaphore;
SemaphoreHandle_t uartInputSemaphore;

static char stopWaiting = 0;

void vUARTInputStop (void)
{
  stopWaiting = 1;
}


void vUARTInputStart( void )
{
  stringRcvSemaphore = xSemaphoreCreateBinary();
  uartInputSemaphore = xSemaphoreCreateBinary();
  osThreadDef(UARTInputTask, prvUARTInputTask, osPriorityLow, 0, 512);
  UARTInputTaskHandle = osThreadCreate(osThread(UARTInputTask), NULL);
}
/*-----------------------------------------------------------*/

static void prvUARTInputTask(void const * pvParameters )
{
  char cRxedChar, cInputIndex = 0;
  static char cLastInputString[ INPUT_SIZE ];
  static char waiting = 0;
  ( void ) pvParameters;
  
  for( ;; )
  {
    xSemaphoreTake (uartInputSemaphore, portMAX_DELAY);
    waiting = 1;
    while (waiting == 1)
    {
      strcpy(string_output, "");
      /* Only interested in reading one character at a time. */
      if( xSemaphoreTake( uart3Semaphore, portMAX_DELAY ) == pdTRUE )
      {
        HAL_UART_Receive_IT(&huart3, (uint8_t *) &cRxedChar, sizeof( cRxedChar ) );
      }
    
      /*Wait for a character to be received*/
      while ((ulTaskNotifyTake( pdTRUE, WAIT_TIME_1MS ) == pdFALSE) && (stopWaiting == 0));
      
      if (stopWaiting)
      {
          xSemaphoreGive(uart3Semaphore);
          stopWaiting = 0;
          waiting = 0;
      }
      /* Backspace is managed elsewhere */
      if( cRxedChar != '\b' )
      {
        /*Format cRxedChar in a string to use strcat*/
        char cToStr[2];
        cToStr[0] = cRxedChar;
        cToStr[1] = '\0';
        /* Echo the character back. */
        strcat(string_output, ( char * ) (cToStr));
      }
    
      if( cRxedChar == '\r' )
      {


        /* The input command string is complete.  Ensure the previous
        UART transmission has finished before sending any more data.
        This task will be held in the Blocked state while the Tx completes,
        if it has not already done so, so no CPU time will be wasted by
        polling. */
        strcat(string_output, ( char * ) pcNewLine);
      
        /* Pass the received string to the waiting task.  */
      
        xSemaphoreGive(stringRcvSemaphore);
        waiting = 0;
        /* Write the generated string to the UART. */

        /* All the strings generated by the input command have been sent.
        Clear the input	string ready to receive the next command.  Remember
        the command that was just processed first in case it is to be
        processed again. */
        strcpy( ( char * ) cLastInputString, ( char * ) UART_Input_String );
        cInputIndex = 0;
        memset( UART_Input_String, 0x00, INPUT_SIZE );

      }
      else
      {
        if( cRxedChar == '\n' )
        {
          /* Ignore the character. */
        }
        else if( cRxedChar == '\b' )
        {
          /* Backspace was pressed.  Erase the last character in the
          string - if any. */
          if( cInputIndex > 0 )
          {       
            uint8_t* backspace = "\b \b";
            strcat(string_output, ( char * ) backspace);
            cInputIndex--;
            UART_Input_String[ cInputIndex ] = '\0';
          }
        }
        else
        {
          /* A character was entered.  Add it to the string
          entered so far.  When a \r is entered the complete
          string will be passed to the command interpreter. */
          if( ( cRxedChar >= ' ' ) && ( cRxedChar <= '~' ) )
          {
            if( cInputIndex < INPUT_SIZE )
            {
              UART_Input_String[ cInputIndex ] = cRxedChar;
              cInputIndex++;
            }
          }
        }
      }
      /*Send back the UART response, wait for the binary semaphore to be available*/
      if(strlen( ( char * ) string_output ) != 0){
        if( xSemaphoreTake( uart3Semaphore, portMAX_DELAY ) == pdTRUE )
        {
          HAL_UART_Transmit_IT(&huart3, (uint8_t *) string_output, strlen( ( char * ) string_output ) );
        }
      }
    }
  }
}
